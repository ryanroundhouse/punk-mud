<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PUNK MUD - Event Builder</title>
    <style>
        :root {
            --neon-pink: #ff2e88;
            --neon-blue: #00fff9;
            --dark-bg: #0a0a0f;
            --terminal-green: #00ff00;
        }

        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: var(--dark-bg);
            font-family: 'Courier New', monospace;
            color: var(--terminal-green);
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: 
                linear-gradient(45deg, #1a1a1f 25%, transparent 25%),
                linear-gradient(-45deg, #1a1a1f 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #1a1a1f 75%),
                linear-gradient(-45deg, transparent 75%, #1a1a1f 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .builder-container {
            width: 95%;
            height: 90vh;
            background: rgba(10, 10, 15, 0.95);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 0 20px var(--neon-pink),
                       0 0 40px rgba(255, 46, 136, 0.3);
            position: relative;
        }

        .layout-container {
            display: flex;
            gap: 2rem;
            height: 100%;
        }

        .left-panel {
            flex: 1;
            height: 100%;
            position: relative;
        }

        .event-form {
            background: rgba(0, 0, 0, 0.7);
            padding: 2rem;
            border-radius: 5px;
            border: 1px solid var(--terminal-green);
            height: calc(100% - 5rem);
            box-sizing: border-box;
            position: relative;
            margin-top: 5rem;
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--neon-blue);
        }

        input[type="text"],
        textarea,
        select {
            width: 100%;
            background: rgba(0, 255, 249, 0.1);
            border: 1px solid var(--neon-blue);
            padding: 0.8rem;
            border-radius: 5px;
            color: var(--terminal-green);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            box-sizing: border-box;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .branch-container {
            border: 1px solid var(--neon-blue);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            background: rgba(0, 255, 249, 0.05);
        }

        .choice-container {
            margin-left: 2rem;
            padding: 1rem;
            border-left: 2px solid var(--neon-pink);
            margin-top: 1rem;
            background: rgba(255, 46, 136, 0.05);
        }

        .action-button {
            background: transparent;
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
            border-radius: 5px;
        }

        .action-button:hover {
            background: rgba(0, 255, 249, 0.1);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .delete-button {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
        }

        .delete-button:hover {
            background: rgba(255, 46, 136, 0.1);
            box-shadow: 0 0 10px var(--neon-pink);
        }

        .hidden {
            display: none;
        }

        .right-panel {
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--terminal-green);
            border-radius: 5px;
            padding: 1rem;
            height: calc(100% - 2rem);
            overflow-y: auto;
        }

        .event-entry {
            border: 1px solid var(--neon-blue);
            margin: 0.5rem 0;
            padding: 1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .event-entry:hover {
            background: rgba(0, 255, 249, 0.1);
            transform: translateX(5px);
        }

        .event-title {
            color: var(--neon-blue);
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .remove-branch, 
        .remove-choice {
            color: var(--neon-pink);
            cursor: pointer;
            float: right;
            font-size: 1.2em;
            transition: all 0.3s ease;
        }

        .remove-branch:hover,
        .remove-choice:hover {
            transform: scale(1.2);
            text-shadow: 0 0 5px var(--neon-pink);
        }

        /* Hamburger menu styles */
        .hamburger-menu {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
        }

        .hamburger-button {
            background: transparent;
            border: none;
            color: var(--neon-pink);
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            transition: all 0.3s ease;
        }

        .hamburger-button:hover {
            color: var(--neon-blue);
            transform: scale(1.1);
        }

        .menu-content {
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 0.5rem;
            display: none;
            min-width: 200px;
            box-shadow: 0 0 20px rgba(0, 255, 249, 0.3);
        }

        .menu-content.show {
            display: block;
        }

        .menu-content a {
            display: block;
            color: var(--terminal-green);
            text-decoration: none;
            padding: 0.8rem 1rem;
            transition: all 0.3s ease;
            border-radius: 3px;
        }

        .menu-content a:hover {
            background: rgba(0, 255, 249, 0.1);
            color: var(--neon-blue);
            transform: translateX(5px);
        }

        .menu-content a + a {
            margin-top: 0.2rem;
        }

        /* Scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--neon-blue);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--neon-pink);
        }

        .event-node {
            border: 1px solid var(--neon-blue);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            background: rgba(0, 255, 249, 0.05);
        }

        .node-choices {
            margin-left: 1rem;
            padding-left: 1rem;
            border-left: 2px solid var(--neon-blue);
        }

        .add-subchoice-btn {
            margin-top: 1rem;
            background: rgba(255, 46, 136, 0.1);
        }

        .choice-text {
            min-height: 60px;
        }

        .node-prompt {
            min-height: 80px;
        }

        .skill-check-container {
            border: 1px solid var(--neon-blue);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 5px;
            background: rgba(0, 255, 249, 0.05);
        }
        
        .skill-check-details {
            margin-top: 1rem;
        }
        
        .skill-check-outcomes {
            margin-top: 1rem;
        }
        
        .skill-check-outcome {
            border: 1px solid var(--neon-pink);
            padding: 1rem;
            border-radius: 5px;
        }
        
        .skill-check-outcome:last-child {
            border-color: var(--neon-pink);
        }
        
        .hidden {
            display: none;
        }
        
        /* Cyberpunk styling for skill check target input */
        .skill-check-target-container {
            position: relative;
            margin-bottom: 1rem;
        }
        
        .skill-check-target {
            width: 100%;
            background: rgba(0, 255, 249, 0.1);
            border: 1px solid var(--neon-blue);
            padding: 0.8rem;
            border-radius: 5px;
            color: var(--terminal-green);
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            box-sizing: border-box;
            text-align: center;
            box-shadow: 0 0 10px rgba(0, 255, 249, 0.3);
            transition: all 0.3s ease;
        }
        
        .skill-check-target:focus {
            outline: none;
            border-color: var(--neon-pink);
            box-shadow: 0 0 15px rgba(255, 46, 136, 0.5);
        }
        
        .skill-check-target:hover {
            background: rgba(0, 255, 249, 0.15);
        }
        
        .skill-check-target-label {
            position: absolute;
            top: -10px;
            left: 10px;
            background: var(--dark-bg);
            padding: 0 5px;
            font-size: 0.8rem;
            color: var(--neon-blue);
            z-index: 1;
        }
        
        .skill-check-difficulty {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.7rem;
        }
        
        .skill-check-difficulty span:first-child {
            color: var(--neon-blue);
        }
        
        .skill-check-difficulty span:last-child {
            color: var(--neon-pink);
        }
        
        /* Custom number input arrows */
        .skill-check-target::-webkit-inner-spin-button,
        .skill-check-target::-webkit-outer-spin-button {
            opacity: 1;
            height: 2em;
            width: 1em;
            background: rgba(0, 255, 249, 0.2);
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="hamburger-menu">
        <button class="hamburger-button">☰</button>
        <div class="menu-content">
            <a href="/game.html">Return to Game</a>
            <a href="/actorbuilder.html">Actor Builder</a>
            <a href="/mobbuilder.html">Mob Builder</a>
            <a href="/movebuilder.html">Move Builder</a>
            <a href="/nodebuilder.html">Node Builder</a>
            <a href="/questbuilder.html">Quest Builder</a>
            <a href="/classbuilder.html">Class Builder</a>
            <a href="/eventbuilder.html">Event Builder</a>
        </div>
    </div>

    <div class="builder-container">
        <div class="layout-container">
            <div class="left-panel">
                <button class="action-button" id="newEventBtn">Add New Event</button>
                <div class="event-form" id="eventForm">
                    <div class="form-group">
                        <label for="eventTitle">Event Title:</label>
                        <input type="text" id="eventTitle" required>
                    </div>

                    <div class="form-group">
                        <label for="actorSelect">Actor:</label>
                        <select id="actorSelect"></select>
                    </div>

                    <div class="form-group">
                        <label for="requiresEnergy">Energy Requirement:</label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="requiresEnergy" checked>
                            Requires Energy to Activate
                        </label>
                    </div>
                    
                    <div class="form-group">
                        <label>Event Chances:</label>
                        <div id="eventChancesContainer">
                            <p class="help-text" style="color: var(--neon-blue); font-size: 0.8rem; margin-bottom: 1rem;">
                                Add events with their chances of occurring. Total chances must sum to exactly 100% or be empty.
                            </p>
                            <div id="eventChancesList"></div>
                            <div class="chance-total-container" style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center;">
                                <span>Total Chance:</span>
                                <span id="totalChanceDisplay" style="font-weight: bold;">0%</span>
                            </div>
                            <div style="margin-top: 1rem;">
                                <button class="action-button" id="addEventChanceBtn">Add Event Chance</button>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Event Tree:</label>
                        <div id="eventTree">
                            <div class="event-node root-node">
                                <div class="form-group">
                                    <label>Initial Prompt:</label>
                                    <textarea class="node-prompt" required></textarea>
                                </div>
                                <div class="form-group">
                                    <label>Restrictions:</label>
                                    <div class="restrictions-container">
                                        <label class="checkbox-label">
                                            <input type="checkbox" class="restriction-checkbox" value="noClass"> No Class Only
                                        </label>
                                        <label class="checkbox-label">
                                            <input type="checkbox" class="restriction-checkbox" value="enforcerOnly"> Enforcer Only
                                        </label>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label>Required Quest:</label>
                                    <select class="quest-select">
                                        <option value="">No Quest Required</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Required Quest Event ID:</label>
                                    <input type="text" class="quest-event-id" placeholder="Quest event ID...">
                                </div>
                                <div class="form-group">
                                    <label>Activate Quest:</label>
                                    <select class="quest-select">
                                        <option value="">No Quest to Activate</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Complete Quest Events (comma-separated IDs):</label>
                                    <input type="text" class="quest-events" placeholder="Quest event IDs...">
                                </div>
                                <div class="node-choices"></div>
                                <button class="action-button add-choice-btn">Add Choice</button>
                            </div>
                        </div>
                    </div>

                    <div class="form-actions">
                        <button class="action-button delete-button hidden" id="deleteEventBtn">Delete Event</button>
                        <button class="action-button" id="saveEventBtn">Save Event</button>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="filter-container">
                    <input type="text" 
                           id="eventFilter" 
                           placeholder="Filter events..."
                           class="chat-input">
                </div>
                <div class="events-list" id="eventsListPanel">
                    <!-- Events will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize variables
        let allEvents = [];
        let allActors = [];
        let allQuests = [];
        let allMobs = [];
        let allNodes = [];
        let eventChances = [];

        // Check authentication and load data
        window.onload = async () => {
            const token = localStorage.getItem('token');
            if (!token) {
                window.location.href = '/';
                return;
            }

            try {
                // First verify the token
                const response = await fetch('/api/auth/verify-token', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Invalid token');
                }

                // Then verify builder access
                const builderResponse = await fetch('/api/events', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!builderResponse.ok) {
                    // If not a builder, redirect to game
                    window.location.href = '/game.html';
                    return;
                }

                // Load data only if builder access is verified
                await Promise.all([
                    loadActors(),
                    loadQuests(),
                    loadMobs(),
                    loadNodes(),
                    loadEvents()
                ]);
                
                newEventBtn.click();
            } catch (error) {
                console.error('Authentication error:', error);
                window.location.href = '/';
            }
        };

        // Load actors
        async function loadActors() {
            try {
                const response = await fetch('/api/actors', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to load actors');
                }

                allActors = await response.json();
                populateActorSelect();
            } catch (error) {
                console.error('Error loading actors:', error);
                alert('Failed to load actors');
            }
        }

        // Populate actor select
        function populateActorSelect() {
            const actorSelect = document.getElementById('actorSelect');
            actorSelect.innerHTML = '<option value="">Select Actor</option>';
            allActors.forEach(actor => {
                const option = document.createElement('option');
                option.value = actor._id;
                option.textContent = actor.name;
                actorSelect.appendChild(option);
            });
        }

        // Load quests
        async function loadQuests() {
            try {
                const response = await fetch('/api/quests', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to load quests: ${response.status}`);
                }

                allQuests = await response.json();
                console.log('Loaded quests:', allQuests); // For debugging
                
                // Update all quest select elements
                document.querySelectorAll('.quest-select').forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = `
                        <option value="">No Quest</option>
                        ${allQuests.map(quest => `
                            <option value="${quest._id}" ${quest._id === currentValue ? 'selected' : ''}>
                                ${quest.title}
                            </option>
                        `).join('')}
                    `;
                });
            } catch (error) {
                console.error('Error loading quests:', error);
                // Don't show alert, just log the error
                // This prevents the error from blocking the UI
            }
        }

        // Update all quest select elements
        function updateQuestSelects() {
            if (!allQuests || allQuests.length === 0) {
                console.warn('No quests available to populate selects');
                return;
            }

            document.querySelectorAll('.quest-select').forEach(select => {
                const currentValue = select.value;
                select.innerHTML = `
                    <option value="">No Quest</option>
                    ${allQuests.map(quest => `
                        <option value="${quest._id}" ${quest._id === currentValue ? 'selected' : ''}>
                            ${quest.title}
                        </option>
                    `).join('')}
                `;
            });
        }

        // Update all teleport selects
        function updateTeleportSelects() {
            if (!allNodes || allNodes.length === 0) {
                console.warn('No nodes available to populate teleport selects');
                return;
            }
            
            document.querySelectorAll('.teleport-select').forEach(select => {
                const currentValue = select.value;
                select.innerHTML = `
                    <option value="">No Teleport</option>
                    ${allNodes.map(node => `
                        <option value="${node.address}" ${node.address === currentValue ? 'selected' : ''}>
                            ${node.name} (${node.address})
                        </option>
                    `).join('')}
                `;
            });
        }

        // Load mobs
        async function loadMobs() {
            try {
                const response = await fetch('/api/mobs', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to load mobs');
                }

                allMobs = await response.json();
                console.log('Loaded mobs:', allMobs); // For debugging
            } catch (error) {
                console.error('Error loading mobs:', error);
                // Don't show alert, just log the error
            }
        }

        // Load nodes
        async function loadNodes() {
            try {
                const response = await fetch('/api/nodes', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to load nodes');
                }

                allNodes = await response.json();
                console.log('Loaded nodes:', allNodes); // For debugging
            } catch (error) {
                console.error('Error loading nodes:', error);
                // Don't show alert, just log the error
            }
        }

        // Load events
        async function loadEvents() {
            try {
                const response = await fetch('/api/events', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to load events');
                }

                allEvents = await response.json();
                filterAndDisplayEvents();
                
                // Update teleport selects with the new events
                updateTeleportSelects();
            } catch (error) {
                console.error('Error loading events:', error);
                alert('Failed to load events');
            }
        }

        // Create event node
        function createEventNode(nodeData = {}) {
            const nodeContainer = document.createElement('div');
            nodeContainer.className = 'event-node';
            
            // For debugging
            console.log('Creating event node with data:', nodeData);
            console.log('Available quests:', allQuests);

            nodeContainer.innerHTML = `
                <div class="form-group">
                    <label>Response Prompt:</label>
                    <textarea class="node-prompt" required>${nodeData.prompt || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Restrictions:</label>
                    <div class="restrictions-container">
                        <label class="checkbox-label">
                            <input type="checkbox" class="restriction-checkbox" value="noClass"
                                ${nodeData.restrictions?.includes('noClass') ? 'checked' : ''}> No Class Only
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" class="restriction-checkbox" value="enforcerOnly"
                                ${nodeData.restrictions?.includes('enforcerOnly') ? 'checked' : ''}> Enforcer Only
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label>Required Quest:</label>
                    <select class="quest-select">
                        <option value="">No Quest Required</option>
                        ${allQuests?.map(quest => `
                            <option value="${quest._id}" ${quest._id === nodeData.requiredQuestId ? 'selected' : ''}>
                                ${quest.title}
                            </option>
                        `).join('') || ''}
                    </select>
                </div>
                <div class="form-group">
                    <label>Required Quest Event ID:</label>
                    <input type="text" class="quest-event-id" value="${nodeData.requiredQuestEventId || ''}" placeholder="Quest event ID...">
                </div>
                <div class="form-group">
                    <label>Activate Quest:</label>
                    <select class="quest-select">
                        <option value="">No Quest to Activate</option>
                        ${allQuests?.map(quest => `
                            <option value="${quest._id}" ${quest._id === nodeData.activateQuestId ? 'selected' : ''}>
                                ${quest.title}
                            </option>
                        `).join('') || ''}
                    </select>
                </div>
                <div class="form-group">
                    <label>Complete Quest Events (comma-separated IDs):</label>
                    <input type="text" class="quest-events" value="${nodeData?.questCompletionEvents?.join(',') || ''}" placeholder="Quest event IDs...">
                </div>
                <div class="node-choices"></div>
                <button class="action-button add-choice-btn">Add Choice</button>
            `;

            // Add choice button handler
            nodeContainer.querySelector('.add-choice-btn').addEventListener('click', () => {
                const choicesContainer = nodeContainer.querySelector('.node-choices');
                addChoice(choicesContainer);
            });

            // Add existing choices if any
            if (nodeData.choices) {
                nodeData.choices.forEach(choice => {
                    const choiceContainer = addChoice(nodeContainer.querySelector('.node-choices'));
                    choiceContainer.querySelector('.choice-text').value = choice.text;
                    
                    // Handle mob selection if present
                    if (choice.mobId) {
                        const mobSelect = choiceContainer.querySelector('.mob-select');
                        const mobId = typeof choice.mobId === 'object' ? choice.mobId._id : choice.mobId;
                        mobSelect.value = mobId;
                        
                        // Trigger the change event to disable the add response button
                        const event = new Event('change');
                        mobSelect.dispatchEvent(event);
                    }
                    // Handle teleport selection if present
                    else if (choice.teleportToNode) {
                        const teleportSelect = choiceContainer.querySelector('.teleport-select');
                        teleportSelect.value = choice.teleportToNode;
                        
                        // Trigger the change event to update UI
                        const event = new Event('change');
                        teleportSelect.dispatchEvent(event);
                        
                        // Also handle next node if it exists (for response after teleport)
                        if (choice.nextNode) {
                            const nextNode = createEventNode(choice.nextNode);
                            choiceContainer.querySelector('.next-node-container').appendChild(nextNode);
                        }
                    }
                    // Handle skill check if present
                    else if (choice.skillCheckStat) {
                        const hasSkillCheckBox = choiceContainer.querySelector('.has-skill-check');
                        hasSkillCheckBox.checked = true;
                        
                        // Trigger the change event to show skill check details
                        const event = new Event('change');
                        hasSkillCheckBox.dispatchEvent(event);
                        
                        // Set skill check values
                        choiceContainer.querySelector('.skill-check-stat').value = choice.skillCheckStat;
                        choiceContainer.querySelector('.skill-check-target').value = choice.skillCheckTargetNumber;
                        
                        // Initialize the difficulty indicator
                        updateDifficultyIndicator(choiceContainer.querySelector('.skill-check-target'));
                        
                        // Add success node (nextNode) if it exists
                        if (choice.nextNode) {
                            const successNode = createEventNode(choice.nextNode);
                            choiceContainer.querySelector('.next-node-container').appendChild(successNode);
                            
                            // Add a label to indicate this is the success outcome
                            const nextNodeContainer = choiceContainer.querySelector('.next-node-container');
                            if (nextNodeContainer && !nextNodeContainer.querySelector('.success-outcome-label')) {
                                const successLabel = document.createElement('p');
                                successLabel.className = 'success-outcome-label';
                                successLabel.style.color = 'var(--neon-blue)';
                                successLabel.style.fontSize = '0.8rem';
                                successLabel.style.marginBottom = '0.5rem';
                                successLabel.innerHTML = '<strong>Success Outcome:</strong> This response is shown when the skill check passes.';
                                nextNodeContainer.insertBefore(successLabel, nextNodeContainer.firstChild);
                            }
                        }
                        
                        // Add failure node if it exists
                        if (choice.failureNode) {
                            const failureNode = createEventNode(choice.failureNode);
                            choiceContainer.querySelector('.failure-node-container').appendChild(failureNode);
                        }
                    }
                    // Otherwise handle next node if it exists
                    else if (choice.nextNode) {
                        const nextNode = createEventNode(choice.nextNode);
                        choiceContainer.querySelector('.next-node-container').appendChild(nextNode);
                    }
                });
            }

            // Ensure quest selects are properly populated
            updateQuestSelects();
            
            // Ensure teleport selects are properly populated
            updateTeleportSelects();

            return nodeContainer;
        }

        // Function to update difficulty indicator
        function updateDifficultyIndicator(input) {
            const value = parseInt(input.value);
            const difficultySpans = input.parentNode.querySelector('.skill-check-difficulty').children;
            
            // Reset all spans to default color
            for (let span of difficultySpans) {
                span.style.color = '';
            }
            
            // Highlight the appropriate difficulty level
            if (value <= 5) {
                difficultySpans[0].style.color = 'var(--terminal-green)';
            } else if (value <= 10) {
                difficultySpans[1].style.color = 'var(--neon-blue)';
            } else if (value <= 15) {
                difficultySpans[2].style.color = 'var(--neon-pink)';
            } else {
                difficultySpans[3].style.color = '#ff0000';
                difficultySpans[3].style.textShadow = '0 0 5px #ff0000';
            }
        }

        // Add choice to event node
        function addChoice(container) {
            const choiceContainer = document.createElement('div');
            choiceContainer.className = 'choice-container';
            choiceContainer.innerHTML = `
                <span class="remove-choice">×</span>
                <div class="form-group">
                    <label>Choice Text:</label>
                    <textarea class="choice-text" required></textarea>
                </div>
                <div class="form-group">
                    <label>Combat Mob (optional):</label>
                    <select class="mob-select">
                        <option value="">No Combat</option>
                        ${allMobs.map(mob => `
                            <option value="${mob._id}">${mob.name}</option>
                        `).join('')}
                    </select>
                    <p class="help-text" style="color: var(--neon-blue); font-size: 0.8rem; margin-top: 0.3rem;">
                        If a mob is selected, this choice will be a leaf node that spawns the mob and initiates combat.
                    </p>
                </div>
                
                <div class="form-group">
                    <label>Teleport to Location (optional):</label>
                    <select class="teleport-select">
                        <option value="">No Teleport</option>
                        ${allNodes.map(node => `
                            <option value="${node.address}">${node.name} (${node.address})</option>
                        `).join('')}
                    </select>
                    <p class="help-text" style="color: var(--neon-blue); font-size: 0.8rem; margin-top: 0.3rem;">
                        If a location is selected, the player will be teleported to this location when they select this choice. You can also add a response that will be shown after teleporting.
                    </p>
                </div>
                
                <div class="form-group skill-check-container">
                    <label class="checkbox-label">
                        <input type="checkbox" class="has-skill-check"> Add Skill Check
                    </label>
                    
                    <div class="skill-check-details hidden">
                        <div class="form-group">
                            <label>Stat to Check:</label>
                            <select class="skill-check-stat">
                                <option value="body">Body</option>
                                <option value="reflexes">Reflexes</option>
                                <option value="agility">Agility</option>
                                <option value="charisma">Charisma</option>
                                <option value="tech">Tech</option>
                                <option value="luck">Luck</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <div class="skill-check-target-container">
                                <span class="skill-check-target-label">TARGET NUMBER</span>
                                <input type="number" class="skill-check-target" min="1" max="20" value="5">
                                <div class="skill-check-difficulty">
                                    <span>EASY</span>
                                    <span>MEDIUM</span>
                                    <span>HARD</span>
                                    <span>EXTREME</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="skill-check-outcomes">
                            <div class="skill-check-outcome">
                                <h4 style="color: var(--neon-pink);">Failure Outcome</h4>
                                <div class="failure-node-container"></div>
                                <button class="action-button add-failure-response-btn">Add Failure Response</button>
                                <p class="help-text" style="color: var(--neon-pink); font-size: 0.8rem; margin-top: 0.3rem;">
                                    This is the path taken when the skill check fails.
                                </p>
                            </div>
                        </div>
                        <p class="help-text" style="color: var(--neon-blue); font-size: 0.8rem; margin-top: 0.5rem;">
                            <strong>Note:</strong> Use the "Add Response" button below to add the success outcome (shown when skill check passes).
                        </p>
                    </div>
                </div>
                
                <div class="next-node-container"></div>
                <button class="action-button add-response-btn">Add Response</button>
            `;

            // Add remove handler
            choiceContainer.querySelector('.remove-choice').addEventListener('click', (e) => {
                e.preventDefault();
                if (confirm('Are you sure you want to remove this choice and all its responses?')) {
                    choiceContainer.remove();
                }
            });

            // Add response button handler
            choiceContainer.querySelector('.add-response-btn').addEventListener('click', (e) => {
                e.preventDefault();
                const mobSelect = choiceContainer.querySelector('.mob-select');
                const nextNodeContainer = choiceContainer.querySelector('.next-node-container');
                
                // If a mob is selected, don't allow adding a response node
                if (mobSelect.value) {
                    alert('Cannot add a response to a combat choice. This choice will spawn a mob and initiate combat.');
                    return;
                }
                
                if (!nextNodeContainer.querySelector('.event-node')) {
                    const nextNode = createEventNode();
                    nextNodeContainer.appendChild(nextNode);
                }
            });
            
            // Add mob select change handler to disable/enable response button
            const mobSelect = choiceContainer.querySelector('.mob-select');
            mobSelect.addEventListener('change', () => {
                const addResponseBtn = choiceContainer.querySelector('.add-response-btn');
                const nextNodeContainer = choiceContainer.querySelector('.next-node-container');
                const skillCheckContainer = choiceContainer.querySelector('.skill-check-container');
                const teleportSelect = choiceContainer.querySelector('.teleport-select');
                
                if (mobSelect.value) {
                    // If a mob is selected, disable the add response button and remove any existing response
                    addResponseBtn.disabled = true;
                    addResponseBtn.style.opacity = '0.5';
                    nextNodeContainer.innerHTML = '';
                    
                    // Also disable skill check
                    skillCheckContainer.style.opacity = '0.5';
                    skillCheckContainer.querySelector('.has-skill-check').disabled = true;
                    skillCheckContainer.querySelector('.has-skill-check').checked = false;
                    skillCheckContainer.querySelector('.skill-check-details').classList.add('hidden');
                    
                    // Also disable teleport select
                    teleportSelect.value = '';
                    teleportSelect.disabled = true;
                    teleportSelect.style.opacity = '0.5';
                    
                    // Remove any skill check success note
                    const successNote = choiceContainer.querySelector('.skill-check-success-note');
                    if (successNote) {
                        successNote.remove();
                    }
                    
                    // Remove any teleport note
                    const teleportNote = choiceContainer.querySelector('.teleport-note');
                    if (teleportNote) {
                        teleportNote.remove();
                    }
                } else {
                    // If no mob is selected, enable the add response button
                    addResponseBtn.disabled = false;
                    addResponseBtn.style.opacity = '1';
                    
                    // Also enable skill check
                    skillCheckContainer.style.opacity = '1';
                    skillCheckContainer.querySelector('.has-skill-check').disabled = false;
                    
                    // Also enable teleport select
                    teleportSelect.disabled = false;
                    teleportSelect.style.opacity = '1';
                }
            });
            
            // Add teleport select change handler
            const teleportSelect = choiceContainer.querySelector('.teleport-select');
            teleportSelect.addEventListener('change', () => {
                const addResponseBtn = choiceContainer.querySelector('.add-response-btn');
                const nextNodeContainer = choiceContainer.querySelector('.next-node-container');
                const skillCheckContainer = choiceContainer.querySelector('.skill-check-container');
                const mobSelect = choiceContainer.querySelector('.mob-select');
                
                if (teleportSelect.value) {
                    // If a teleport is selected, we still allow adding a response
                    // but disable mob selection
                    
                    // Disable mob select
                    mobSelect.value = '';
                    mobSelect.disabled = true;
                    mobSelect.style.opacity = '0.5';
                    
                    // Add a note about teleporting
                    const teleportNote = document.createElement('p');
                    teleportNote.className = 'teleport-note';
                    teleportNote.style.color = 'var(--neon-blue)';
                    teleportNote.style.fontSize = '0.8rem';
                    teleportNote.style.marginTop = '0.5rem';
                    teleportNote.innerHTML = '<strong>Note:</strong> This choice will teleport the player to the selected location. You can add a response below that will be shown after teleporting.';
                    
                    // Add the note if it doesn't exist
                    if (!choiceContainer.querySelector('.teleport-note')) {
                        const teleportContainer = teleportSelect.closest('.form-group');
                        teleportContainer.appendChild(teleportNote);
                    }
                    
                    // Change the add response button text
                    addResponseBtn.textContent = 'Add Post-Teleport Response';
                } else {
                    // If no teleport is selected, enable mob select
                    mobSelect.disabled = false;
                    mobSelect.style.opacity = '1';
                    
                    // Remove the teleport note if it exists
                    const teleportNote = choiceContainer.querySelector('.teleport-note');
                    if (teleportNote) {
                        teleportNote.remove();
                    }
                    
                    // Reset the add response button text
                    addResponseBtn.textContent = 'Add Response';
                }
            });
            
            // Add skill check checkbox handler
            const hasSkillCheckBox = choiceContainer.querySelector('.has-skill-check');
            hasSkillCheckBox.addEventListener('change', () => {
                const skillCheckDetails = choiceContainer.querySelector('.skill-check-details');
                const addResponseBtn = choiceContainer.querySelector('.add-response-btn');
                const teleportSelect = choiceContainer.querySelector('.teleport-select');
                
                if (hasSkillCheckBox.checked) {
                    skillCheckDetails.classList.remove('hidden');
                    // Don't hide the add response button anymore, as it's used for adding the success outcome
                    
                    // Clear any existing failure node
                    choiceContainer.querySelector('.failure-node-container').innerHTML = '';
                    
                    // Add explanatory text above the Add Response button
                    const responseButtonContainer = choiceContainer.querySelector('.add-response-btn').parentNode;
                    if (!responseButtonContainer.querySelector('.skill-check-success-note')) {
                        const successNote = document.createElement('p');
                        successNote.className = 'skill-check-success-note';
                        successNote.style.color = 'var(--neon-blue)';
                        successNote.style.fontSize = '0.8rem';
                        successNote.style.marginTop = '0.5rem';
                        successNote.style.marginBottom = '0.5rem';
                        successNote.innerHTML = '<strong>Success Outcome:</strong> Add a response below for what happens when the skill check passes.';
                        responseButtonContainer.insertBefore(successNote, choiceContainer.querySelector('.add-response-btn'));
                    }
                } else {
                    skillCheckDetails.classList.add('hidden');
                    
                    // Clear any existing failure node
                    choiceContainer.querySelector('.failure-node-container').innerHTML = '';
                    
                    // Remove explanatory text if it exists
                    const successNote = choiceContainer.querySelector('.skill-check-success-note');
                    if (successNote) {
                        successNote.remove();
                    }
                    
                    // Also remove any success label that might have been added to the next node container
                    const successLabel = choiceContainer.querySelector('.success-outcome-label');
                    if (successLabel) {
                        successLabel.remove();
                    }
                }
            });
            
            // Add failure response button handler
            choiceContainer.querySelector('.add-failure-response-btn').addEventListener('click', (e) => {
                e.preventDefault();
                const failureNodeContainer = choiceContainer.querySelector('.failure-node-container');
                
                if (!failureNodeContainer.querySelector('.event-node')) {
                    const failureNode = createEventNode();
                    failureNodeContainer.appendChild(failureNode);
                }
            });

            // Add event listener to update difficulty indicator
            choiceContainer.querySelector('.skill-check-target').addEventListener('input', function() {
                updateDifficultyIndicator(this);
            });
            
            // Initialize the difficulty indicator
            updateDifficultyIndicator(choiceContainer.querySelector('.skill-check-target'));

            container.appendChild(choiceContainer);
            return choiceContainer;
        }

        // Filter and display events
        function filterAndDisplayEvents() {
            const filterValue = document.getElementById('eventFilter').value.toLowerCase();
            const container = document.getElementById('eventsListPanel');
            container.innerHTML = '';

            allEvents
                .filter(event => event.title.toLowerCase().includes(filterValue))
                .forEach(event => {
                    const eventEntry = document.createElement('div');
                    eventEntry.className = 'event-entry';
                    eventEntry.innerHTML = `
                        <div class="event-title">${event.actorId ? 'C - ' : ''}${event.title}</div>
                    `;
                    eventEntry.addEventListener('click', () => loadEventData(event));
                    container.appendChild(eventEntry);
                });
        }

        // Load event data
        function loadEventData(event) {
            document.getElementById('eventForm').dataset.eventId = event._id;
            document.getElementById('deleteEventBtn').classList.remove('hidden');
            document.getElementById('eventTitle').value = event.title;
            document.getElementById('actorSelect').value = event.actorId?._id || '';
            document.getElementById('requiresEnergy').checked = event.requiresEnergy !== false;
            
            // Load event chances
            eventChances = event.events || [];
            renderEventChances();
            
            // Clear and rebuild the event tree
            const eventTree = document.getElementById('eventTree');
            eventTree.innerHTML = '';
            
            // Create root node with the event's root node data
            const rootNode = createEventNode({
                ...event.rootNode,
                requiredQuestId: event.rootNode.requiredQuestId?._id || event.rootNode.requiredQuestId,
                activateQuestId: event.rootNode.activateQuestId?._id || event.rootNode.activateQuestId
            });
            rootNode.classList.add('root-node');
            eventTree.appendChild(rootNode);
            
            // Ensure quest selects are properly populated
            updateQuestSelects();
            
            // Ensure teleport selects are properly populated
            updateTeleportSelects();
        }

        // Render event chances
        function renderEventChances() {
            const container = document.getElementById('eventChancesList');
            container.innerHTML = '';
            
            eventChances.forEach((chance, index) => {
                const chanceItem = document.createElement('div');
                chanceItem.className = 'event-chance-item';
                chanceItem.style.display = 'flex';
                chanceItem.style.alignItems = 'center';
                chanceItem.style.marginBottom = '0.5rem';
                chanceItem.style.padding = '0.5rem';
                chanceItem.style.border = '1px solid var(--neon-blue)';
                chanceItem.style.borderRadius = '5px';
                chanceItem.style.background = 'rgba(0, 255, 249, 0.05)';
                
                chanceItem.innerHTML = `
                    <div style="flex: 1;">
                        <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem;">
                            <div style="flex: 2;">
                                <label style="color: var(--neon-blue); font-size: 0.8rem;">Type</label>
                                <select class="event-type-select" style="width: 100%;">
                                    <option value="mob" ${chance.mobId ? 'selected' : ''}>Mob</option>
                                    <option value="event" ${chance.eventId ? 'selected' : ''}>Event</option>
                                </select>
                            </div>
                            <div style="flex: 3;">
                                <label style="color: var(--neon-blue); font-size: 0.8rem;">ID</label>
                                <select class="event-id-select" style="width: 100%;">
                                    ${chance.mobId ? 
                                        allMobs.map(mob => `
                                            <option value="${mob._id}" ${mob._id === chance.mobId ? 'selected' : ''}>
                                                ${mob.name}
                                            </option>
                                        `).join('') : 
                                        allEvents.map(event => `
                                            <option value="${event._id}" ${event._id === chance.eventId ? 'selected' : ''}>
                                                ${event.title}
                                            </option>
                                        `).join('')
                                    }
                                </select>
                            </div>
                            <div style="flex: 1;">
                                <label style="color: var(--neon-blue); font-size: 0.8rem;">Chance (%)</label>
                                <input type="number" class="event-chance-input" value="${chance.chance}" min="1" max="100" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    <button class="action-button delete-button" style="margin-left: 0.5rem;">×</button>
                `;
                
                // Add event listeners
                chanceItem.querySelector('.event-type-select').addEventListener('change', (e) => {
                    const type = e.target.value;
                    const idSelect = chanceItem.querySelector('.event-id-select');
                    
                    // Update the ID select options based on the type
                    if (type === 'mob') {
                        idSelect.innerHTML = allMobs.map(mob => `
                            <option value="${mob._id}">${mob.name}</option>
                        `).join('');
                    } else {
                        idSelect.innerHTML = allEvents.map(event => `
                            <option value="${event._id}">${event.title}</option>
                        `).join('');
                    }
                    
                    // Update the event chance data
                    if (type === 'mob') {
                        eventChances[index] = {
                            mobId: idSelect.value,
                            chance: parseInt(chanceItem.querySelector('.event-chance-input').value)
                        };
                    } else {
                        eventChances[index] = {
                            eventId: idSelect.value,
                            chance: parseInt(chanceItem.querySelector('.event-chance-input').value)
                        };
                    }
                    
                    updateTotalChance();
                });
                
                chanceItem.querySelector('.event-id-select').addEventListener('change', (e) => {
                    const type = chanceItem.querySelector('.event-type-select').value;
                    
                    // Update the event chance data
                    if (type === 'mob') {
                        eventChances[index].mobId = e.target.value;
                    } else {
                        eventChances[index].eventId = e.target.value;
                    }
                });
                
                chanceItem.querySelector('.event-chance-input').addEventListener('input', (e) => {
                    eventChances[index].chance = parseInt(e.target.value) || 0;
                    updateTotalChance();
                });
                
                chanceItem.querySelector('.delete-button').addEventListener('click', () => {
                    eventChances.splice(index, 1);
                    renderEventChances();
                    updateTotalChance();
                });
                
                container.appendChild(chanceItem);
            });
            
            updateTotalChance();
        }
        
        // Update total chance display
        function updateTotalChance() {
            const totalChance = eventChances.reduce((sum, chance) => sum + (parseInt(chance.chance) || 0), 0);
            const totalDisplay = document.getElementById('totalChanceDisplay');
            
            totalDisplay.textContent = `${totalChance}%`;
            
            // Highlight if not 100%
            if (eventChances.length > 0 && totalChance !== 100) {
                totalDisplay.style.color = 'var(--neon-pink)';
            } else {
                totalDisplay.style.color = 'var(--terminal-green)';
            }
        }
        
        // Add event chance button
        document.getElementById('addEventChanceBtn').addEventListener('click', () => {
            // Default to mob type if available, otherwise event
            const type = allMobs.length > 0 ? 'mob' : 'event';
            const id = type === 'mob' ? 
                (allMobs.length > 0 ? allMobs[0]._id : '') : 
                (allEvents.length > 0 ? allEvents[0]._id : '');
            
            // Calculate remaining chance needed to reach 100%
            const currentTotal = eventChances.reduce((sum, chance) => sum + (parseInt(chance.chance) || 0), 0);
            const remainingChance = Math.max(1, 100 - currentTotal);
            
            const newChance = type === 'mob' ? 
                { mobId: id, chance: remainingChance } : 
                { eventId: id, chance: remainingChance };
            
            eventChances.push(newChance);
            renderEventChances();
        });

        // Add event listeners
        document.getElementById('newEventBtn').addEventListener('click', () => {
            document.getElementById('eventForm').dataset.eventId = '';
            document.getElementById('deleteEventBtn').classList.add('hidden');
            document.getElementById('eventTitle').value = '';
            document.getElementById('actorSelect').value = '';
            
            // Clear event chances
            eventChances = [];
            renderEventChances();
            
            // Create the root node structure
            const eventTree = document.getElementById('eventTree');
            eventTree.innerHTML = '';
            const rootNode = createEventNode();
            rootNode.classList.add('root-node');
            eventTree.appendChild(rootNode);
            
            // Update teleport selects
            updateTeleportSelects();
        });

        document.getElementById('eventFilter').addEventListener('input', filterAndDisplayEvents);

        // Save event
        document.getElementById('saveEventBtn').addEventListener('click', async () => {
            try {
                const form = document.getElementById('eventForm');
                
                // Validate event chances
                const totalChance = eventChances.reduce((sum, chance) => sum + (parseInt(chance.chance) || 0), 0);
                if (eventChances.length > 0 && totalChance !== 100) {
                    alert(`Event chances must sum to exactly 100% (current total: ${totalChance}%)`);
                    return;
                }
                
                function getNodeData(nodeElement) {
                    const restrictions = Array.from(nodeElement.querySelectorAll('.restriction-checkbox:checked'))
                        .map(checkbox => checkbox.value);

                    const questSelects = nodeElement.querySelectorAll('.quest-select');
                    const nodeData = {
                        prompt: nodeElement.querySelector('.node-prompt').value,
                        restrictions: restrictions.length > 0 ? restrictions : undefined,
                        requiredQuestId: questSelects[0]?.value || undefined,
                        requiredQuestEventId: nodeElement.querySelector('.quest-event-id').value || undefined,
                        activateQuestId: questSelects[1]?.value || undefined,
                        questCompletionEvents: nodeElement.querySelector('.quest-events').value
                            .split(',')
                            .map(id => id.trim())
                            .filter(id => id.length > 0),
                        choices: []
                    };

                    // Remove undefined fields
                    if (!nodeData.restrictions) delete nodeData.restrictions;
                    if (!nodeData.requiredQuestId) delete nodeData.requiredQuestId;
                    if (!nodeData.requiredQuestEventId) delete nodeData.requiredQuestEventId;
                    if (!nodeData.activateQuestId) delete nodeData.activateQuestId;
                    if (nodeData.questCompletionEvents.length === 0) delete nodeData.questCompletionEvents;

                    // Get all choices for this node
                    const choiceElements = nodeElement.querySelector('.node-choices').children;
                    for (const choiceElement of choiceElements) {
                        const choiceData = {
                            text: choiceElement.querySelector('.choice-text').value
                        };

                        // Get mobId if selected
                        const mobSelect = choiceElement.querySelector('.mob-select');
                        if (mobSelect && mobSelect.value) {
                            choiceData.mobId = mobSelect.value;
                        }
                        // Handle teleport selection if present
                        else if (choiceElement.querySelector('.teleport-select').value) {
                            choiceData.teleportToNode = choiceElement.querySelector('.teleport-select').value;
                            
                            // Also get next node if it exists (for response after teleport)
                            const nextNodeElement = choiceElement.querySelector('.next-node-container > .event-node');
                            if (nextNodeElement) {
                                choiceData.nextNode = getNodeData(nextNodeElement);
                            }
                        }
                        // Check if this choice has a skill check
                        else if (choiceElement.querySelector('.has-skill-check').checked) {
                            const skillCheckStat = choiceElement.querySelector('.skill-check-stat').value;
                            const skillCheckTargetNumber = parseInt(choiceElement.querySelector('.skill-check-target').value);
                            
                            // Get next node (success outcome) if it exists
                            const nextNodeElement = choiceElement.querySelector('.next-node-container > .event-node');
                            if (nextNodeElement) {
                                choiceData.nextNode = getNodeData(nextNodeElement);
                            }
                            
                            // Get failure node if it exists - using direct child selector to prevent conflict
                            const failureNodeElement = choiceElement.querySelector('.failure-node-container > .event-node');
                            if (failureNodeElement) {
                                choiceData.failureNode = getNodeData(failureNodeElement);
                            }
                            
                            choiceData.skillCheckStat = skillCheckStat;
                            choiceData.skillCheckTargetNumber = skillCheckTargetNumber;
                        }
                        // Otherwise handle next node if it exists
                        else {
                            // Get next node if it exists
                            const nextNodeElement = choiceElement.querySelector('.next-node-container > .event-node');
                            if (nextNodeElement) {
                                choiceData.nextNode = getNodeData(nextNodeElement);
                            }
                        }

                        nodeData.choices.push(choiceData);
                    }

                    return nodeData;
                }

                const eventData = {
                    _id: form.dataset.eventId || undefined,
                    title: document.getElementById('eventTitle').value,
                    actorId: document.getElementById('actorSelect').value || undefined,
                    requiresEnergy: document.getElementById('requiresEnergy').checked,
                    rootNode: getNodeData(document.querySelector('.root-node')),
                    events: eventChances.length > 0 ? eventChances : undefined
                };

                const response = await fetch('/api/events', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(eventData)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.details || 'Failed to save event');
                }

                alert('Event saved successfully!');
                await loadEvents();
            } catch (error) {
                console.error('Error saving event:', error);
                alert(`Failed to save event: ${error.message}`);
            }
        });

        // Delete event
        document.getElementById('deleteEventBtn').addEventListener('click', async () => {
            const eventId = document.getElementById('eventForm').dataset.eventId;
            if (!eventId) return;

            if (confirm('Are you sure you want to delete this event?')) {
                try {
                    const response = await fetch(`/api/events/${eventId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('token')}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to delete event');
                    }

                    alert('Event deleted successfully');
                    document.getElementById('newEventBtn').click();
                    await loadEvents();
                } catch (error) {
                    console.error('Error deleting event:', error);
                    alert('Failed to delete event');
                }
            }
        });

        // Hamburger menu functionality
        const hamburgerButton = document.querySelector('.hamburger-button');
        const menuContent = document.querySelector('.menu-content');

        hamburgerButton.addEventListener('click', () => {
            menuContent.classList.toggle('show');
        });

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!hamburgerButton.contains(e.target) && !menuContent.contains(e.target)) {
                menuContent.classList.remove('show');
            }
        });

        // Highlight current page in menu
        document.querySelectorAll('.menu-content a').forEach(link => {
            if (link.href === window.location.href) {
                link.style.color = 'var(--neon-pink)';
            }
        });
    </script>
</body>
</html> 